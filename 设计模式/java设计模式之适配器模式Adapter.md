---
title: java设计模式之适配器模式Adapter 
tags: [设计模式,Adapter]
categories: 设计模式
date: 2019-04-02
---
***简介：***

>Adapter是结构模式之一。把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作



<!-- more -->

**适配器角色**
* Target（目标角色）
	这是所期待得到的接口
* Adaptee（源角色）
	现在需要适配的接口
* Adapter（适配器角色）
	设配器把源接口转换成目标接口，这一角色必须是具体类
	
>Adaptee类和Target 没有关系。其实Adaptee中有功能的实现，但是苦于没有接口关系，通过Target无法使用Adaptee中的功能。这样的情况下，我们的adapter出现了，他在不改变Adaptee和Target之间的关系的前提下，实现了通过Target接口调用了Adaptee的逻辑。



#### 一、类适配器 ####
##### 1.类图 #####
![](https://fuzui.oss-cn-shenzhen.aliyuncs.com/img/20190402153552.png)

##### 2.实现 #####

Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的。

#### 二、对象适配器 ####
##### 1.类图 #####
![](https://fuzui.oss-cn-shenzhen.aliyuncs.com/img/20190402155741.png)

##### 2.实现 #####
Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。

#### 三、类适配器和对象适配器比较 ####
* 类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
* 类适配器直接继承了Adaptee，使适配器不能喝Adaptee的子类一起工作，因为集成是静态的关系，当适配器集成了Adaptee后，就不可能再去处理Adaptee的子类了；
	对象适配器可以把多重不同的源适配到同一个目标，换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。
* 类适配器重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法；
	对象适配器要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增的行为可同时适用于所有的源。
* 类适配器仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee；
	对象适配器需要额外的引用来间接得到Adaptee。
**建议使用对象适配器的实现方式，多用合成/聚合，少用继承。**

#### 四、适配器模式的优缺点 ####
##### 1.优点 #####
* 复用性
	系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。
* 扩展性
	在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。
##### 2.缺点 #####
过多的使用适配器，会让系统非常凌乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不适用适配器，而直接对系统进行重构。

#### 五、缺省适配器 ####
>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。
##### 1.类图 #####
![](https://fuzui.oss-cn-shenzhen.aliyuncs.com/img/20190402163809.png)

##### 2.使用情况 #####

>在很多情况下，必须让一个具体类实现某一个接口，但是这个类又用不到接口所规定的所有的方法。通常的处理方法是，这个具体类要实现所有的方法，那些有用的方法要有实现，那些没有用的方法也要有空的、平庸的实现。
这些空的方法是一种浪费，有时也是一种混乱。除非看过这些空方法的代码，程序员可能会以为这些方法不是空的。即便他知道其中有一些方法是空的，也不一定知道哪些方法是空的，哪些方法不是空的，除非看过这些方法的源代码或是文档。
缺省适配模式可以很好的处理这一情况。可以设计一个抽象的适配器类实现接口，此抽象类要给接口所要求的每一种方法都提供一个空的方法。
适配器模式的用意是要改变源的接口，以便于目标接口相容。缺省适配的用意稍有不同，它是为了方便建立一个不平庸的适配器类而提供的一种平庸实现。
在任何时候，如果不准备实现一个接口的所有方法时，就可以使用“缺省适配模式”制造一个抽象类，给出所有方法的平庸的具体实现。这样，从这个抽象类再继承下去的子类就不必实现所有的方法了。