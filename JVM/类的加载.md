---
title: 类的加载
tags: JVM
categories: JVM
date: 2019-07-01
---

#### 一、类加载过程 ####
>负责查找并加载二进制文件，也就是class字节码文件。

>* 字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
>* 类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。

**类加载器：**

![Diagram](./attachments/1553931903693.drawio.html)


* BootStrap ClassLoader（根类加载器）：
	负责加载核心的类库（java.lang.等   ),构造Ext ClassLoader和APPClassLoader.
* Ext ClassLoader（扩展类加载器）：
	负责加载jre/lib/ext目录下一些扩展的jar
* APPClassLoader（系统类加载器）：
	负责加载应用程序的主函数类
* Custom ClassLoader（自定义加载器）：
	例如tomcat就为自定义加载器
	
``` java
		System.out.println("=====根类加载器=====");
		System.out.println(System.getProperty("sun.boot.class.path"));
		System.out.println("=====扩展类加载器=====");
		System.out.println(System.getProperty("java.ext.dirs"));
		System.out.println("=====系统类加载器=====");
		System.out.println(System.getProperty("java.class.path"));
```
**双亲委派机制：**
>概念：
>>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载.
>
>优点：
>>* 表面重复加载
>>* 安全性




#### 二、类连接过程 ####

##### 1.验证 #####
（1）验证文件格式
	* 魔数因子的验证（类型）
	* 主次版本号
	* MD5
	* 常量池中的常量类型
（2）元数据的验证（语义验证、JVM规范）
	* 验证该类是否存在父类和接口
	* 检查是否被继承了被final修饰的类
	* 检查是否为抽象类
	* 检查方法重载的合法性
（3）字节码的验证
	* 指令跳转的合法性（循环、if）
	* 类型转换的合法性（装箱）
	* 虚拟机栈操作的合法性
（4）符号引用的验证
>符号引用：在编译阶段。符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。个人理解为：在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。
>直接引用：在装载阶段。直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。


* 通过符号应用是否能正确找到相关类
* 验证类、方法、字段的可见性

##### 2.准备 #####
>给静态变量分配空间并赋值为默认值

| 数据类型 | 初始值  |
| -------- | -------- |
| Byte     | (Byte)0  |
| Char     | '\u0000' |
| Short    | (Short)0 |
| Int      | 0        |
| Long     | 0L       |
| Float    | 0.0f     |
| Double   | 0.0D     |
| Boolean  | False    |
| 引用类型 |  null  |

##### 3.解析 #####
* 从常量池中寻找类、接口、字段和方法的符号引用，并且将这些符号引用替换为直接引用。
* 类接口的解析
	对于类不是数组类型，在加载过程中需要先完成对该类的加载
	如果该类是数组，虚拟机不需要完成对该类的加载，只需要在虚拟机中生成代表改类型的数组对象，并且在堆内存中开辟一片连续的地址空间。
* 类方法解析
  类方法可以直接使用该类进行调用：
  如果方法表中发现该类是一个接口，直接保存发发索引
  如果该类查找是否存在与方法描述一致的方法，如果有直接返回这个方法的引用，如果没有，按照继承关系继续向上查找。在父类中没找到会报错。
  如果找到的方法是所属类的一个抽象类，报错。
* 接口方法的解析
	接口方法必须有相应的实现类才能够继续调用接口。
	规范
	JDBC
  


#### 三、类初始化 ####
执行< clinit >()方法   
< clinit >()在编译时期，保存静态变量的赋值在class文件
虚拟机会保证在子类的< clinit >()执行之前，父类的< clinit >()先执行。因此，在虚拟机中第一个被执行的< clinit >()方法一定是java.lang.Object。（JVM规范）

< clinit >()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是根据其在源文件中的顺序决定的，静态语句块中仅能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但不能访问。

某个类或接口中如果不包含静态变量和静态语句块，不会生成< clinit >()方法。

虚拟机会保证在多线程环境下该类的< clinit >()方法会正确的synchronized加锁、同步，也就是只有一个线程会执行该类的< clinit >()方法，其他线程会被阻塞。也就是单例模式中holder设计方式的原理。

**主动模式：**
* 通过new关键字会导致类的初始化
* 访问类的静态变量
* 访问类的静态方法
* 对其各类进行反射操作
* 初始化子类会导致父类的初始化
* 启动类main()方法

**被动模式：**
* 构造其各类数组时不会导致类初始化
* 引用类的静态常量时不会导致类初始化
* 引用*随机函数*时会导致类初始化